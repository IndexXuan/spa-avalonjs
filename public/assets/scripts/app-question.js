define(["http://res.wx.qq.com/open/js/jweixin-1.0.0.js", AvalonLibsBaseUrl + "mmState", "./lib/http/http.js?v=201511022251"], function(wx) { // 此处wx对象必须手动导入内部，不同于其他模式工厂return的对象，内部直接可用。且导入时位置还必须在第一个。fuck...
// AvalonLibsBaseUrl defined in project main file(.html)

    /********* generated by grunt-includereplace **********/

    // ==================== global config area start, @included  ==================== //

    // 变量均来源于gruntfile.js
 
    // 为加载的静态资源加运行时版本号
    var resource_version = '1.1.1.1';

    // 模板基地址配置
    var global_templateBaseUrl = 'assets/templates/';

    // 控制器基地址配置
    var global_controllerBaseUrl = 'scripts/controller/';

    // $http log 开关配置, 依据运行时编译目标的模式, 强调试时打开注释即可
    // $http.debug = true;
    $http.debug = false;
    
    // override: 重写log方法, 使用本项目提供的醒目输出
    $http.log = function(msg) {
        if (this.debug) {
            if (avalon.illyInfo) {
                avalon.illyInfo(msg);
                return;
            }
            console.log(msg);
        }
    };
    
    // override: $http全局ajax request拦截器配置
    $http.requestInterceptor = function(oldSettings) { // 还有一个隐藏参数xhr对象, 尽量不要使用
        // 重置数据获取成功标记
        avalon.vmodels.root.currentDataDone = false;
        var global_headers = {
            'Authorization': 'Bearer ' + token
        };
        var newHeaders = avalon.mix(oldSettings.headers, global_headers);
        oldSettings.headers = newHeaders;

        return oldSettings;
    };
    
    // override: $http全局ajax resolve拦截器配置
    $http.resolveInterceptor = function() {
        // 数据获取成功
        avalon.vmodels.root.currentDataDone = true;

        // repaint the big image of the page, for better user experience
        if (!root.currentIsVisited) {
            var bigImage = document.querySelector('.big-image');
            if (bigImage) {
                bigImage.style.visibility = 'hidden';
                setTimeout(function() {
                    bigImage.style.visibility = 'visible';
                }, global_rendered_bigImage_delay || 300);
            }
        }
    };

    // override: $http全局ajax reject拦截器配置
    $http.rejectInterceptor = function(msg) {
        // 请求失败，去除最后一条页面记录，以便下次继续发起请求
        CACHE_VISITED_PAGEID_CONTAINER.pop();

        if (msg && msg.indexOf('Authorization') >= 0) {
            alert('对不起，您没有Authorization，本系统仅供会员使用！');
        }
        if (msg && msg.indexOf('token') >= 0) {
            alert('对不起，您的token异常，请退出重试！');
        }
    };

    // project domain, by config 
    var illy_domain = 'http://weixin.hizuoye.com'; 

    // project images base src
    var illy_images_base_src = './assets/images';

    // resource base url
    var illy_resource_base_url = 'http://7rfll3.com1.z0.glb.clouddn.com/';

    // global apiBaseUrl
    var apiBaseUrl = 'http://api.hizuoye.com/api/v1/'; 

    // get the token and ready to cache
    var token = localStorage.getItem('illy-token');

    // global view loaded animation, from animation.css, the custom version 
    var global_viewload_animation_name = "a-bounceinR";

    // global config, always show loader when view enter 
    var global_always_show_loader = false;

    // global config, always reset scrollbar when view enter
    var global_always_reset_scrollbar = false;

    // global config, loading timeout
    var global_loading_timeout = 12000; // ms, abort the loading when timeout, then auto goback

    // global config, view loaded with a litle delay for avalon rendering page, time enough
    // var global_loading_delay = 30; // ms
    var global_rendered_time = 88; // ms

    // page is reused so some old page big image will
    // splash in new page, add a delay to better UE. 201511031600
    var global_rendered_bigImage_delay = 500;

    // global config, loader className
    var global_loader_className = '.loader';

    // global config, loader'dom, must ensure the dom is exists
    var global_loader_dom = document.querySelector('.loader');

    // global config, error log style
    var global_errorLog_style = "background-color: red; color: #fff; padding: 3px; border-radius: 3px";
    // global config, error log style
    
    var global_warningLog_style = "background-color: #ff9100; color: #fff; padding: 3px; border-radius: 3px";

    // global config, info log style
    var global_infoLog_style = "background-color: #14e5d5; color: #fff; padding: 3px; border-radius: 3px";

    // global config, record log style
    var global_recordLog_style = "background-color: #64c400; color: #fff; padding: 3px; border-radius: 3px";

    // ==================== global config area end, @included  ==================== //

    
    // ==================== static method start, @included  ==================== //

    avalon.getVM = function(vm) {
        return avalon.vmodels[vm];
    };

    avalon.getPureModel = function(vm) {
        return avalon.vmodels && avalon.vmodels[vm] && avalon.vmodels[vm].$model; // for strong
    };

    avalon.$ = function(selector) {
        return document.querySelector(selector);
    };

    /**
     * illyLog
     * 一系列可以在框架生命周期使用或者在控制台使用的快捷log方法
     *
     * @param type {String}
     * @param msg {String}
     * @param res {String | Object}
     * @param saveToLocalStorage {Boolean}
     *
     */
    var illyLog = function illyLog(type, msg, res, style, saveToLocalStorage) {
        var root = avalon.vmodels.root;
        var namespace = root.namespace;
        var currentVM = root.currentState;
        res = res || '';
        if (typeof res !== 'string') {
            res = JSON.stringify(res);
        }
        console.log('%c' + type.toUpperCase() + ': ' + namespace + ' -> ' + currentVM + ': ' + msg + res, style); 
        if (saveToLocalStorage) {
            localStorage.setItem('illy-record-' + namespace + '-' + currentVM + '-' + Date.now(), msg + ' ' + res);
        }
    };

    avalon.illyWarning = function(msg, res) {
        illyLog('warning', msg, res, global_warningLog_style, false);
    };

    avalon.illyError = function(msg, res) {
        illyLog('error', msg, res, global_errorLog_style, false);
    };

    avalon.illyInfo = function(msg, res) {
        illyLog('info', msg, res, global_infoLog_style, false);
    };

    avalon.illyRecord = function(msg, res) {
        illyLog('record', msg, res, global_recordLog_style, true);
    };

    // 性能统计数据,数据详细，推荐在控制台手动调用
    avalon.illyProfile = function getPerformanceTiming () { 

        var performance = window.performance;
        if (!performance) {
            // 当前浏览器不支持
            console.error('你的浏览器不支持 performance 接口');
            return;
        }

        var t = performance.timing;
        var times = {};

        //【重要】页面加载完成的时间
        //【原因】这几乎代表了用户等待页面可用的时间
        times.loadPage = t.loadEventEnd - t.navigationStart;

        //【重要】解析 DOM 树结构的时间
        //【原因】反省下你的 DOM 树嵌套是不是太多了！
        times.domReady = t.domComplete - t.responseEnd;

        //【重要】重定向的时间
        //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com
        times.redirect = t.redirectEnd - t.redirectStart;

        //【重要】DNS 查询时间
        //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？
        // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)            
        times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;

        //【重要】读取页面第一个字节的时间
        //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？
        // TTFB 即 Time To First Byte 的意思
        // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte
        times.ttfb = t.responseStart - t.navigationStart;

        //【重要】内容加载完成的时间
        //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？
        times.request = t.responseEnd - t.requestStart;

        //【重要】执行 onload 回调函数的时间
        //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？
        times.loadEvent = t.loadEventEnd - t.loadEventStart;

        // DNS 缓存时间
        times.appcache = t.domainLookupStart - t.fetchStart;

        // 卸载页面的时间
        times.unloadEvent = t.unloadEventEnd - t.unloadEventStart;

        // TCP 建立连接完成握手的时间
        times.connect = t.connectEnd - t.connectStart;

        return times;
    };

    // 缓存系统通用函数
    
    /**
     * getLocalCache
     * @param itemName {String}
     * return result   {Object} (json-from-api)
    */
    var getLocalCache = function getLocalCache(itemName) {
        return localStorage.getItem && JSON.parse( '' + localStorage.getItem(itemName) );
    };

    /**
     * setLocalCache
     * @param itemName {String}
     * @param source   {String} (json-like)
    */
    var setLocalCache = function setLocalCache(itemName, source) {
        source = JSON.stringify(source);
        localStorage.setItem && localStorage.setItem( itemName, source ); /* jshint ignore:line */
    };

    /*
     * clearLocalCache
     * @param prefix {string}
     * clear the cache item includes the given prefix
    */
    var clearLocalCache = function clearLocalCache(prefix) {
        for (var key in localStorage) {
            if (key.indexOf(prefix) >= 0) {
                localStorage.removeItem(key);
            }
        }
    };

    // 挂载
    avalon.getLocalCache = getLocalCache;
    avalon.setLocalCache = setLocalCache;
    avalon.clearLocalCache = clearLocalCache;

    // ==================== static method end, @included ==================== //

    
    // ==================== custom project data start @include ==================== //

    // override, because images in this module is big
    global_rendered_bigImage_delay = 600;    

    if (token === null) {
        alert("对不起，本系统仅供内部使用！ ERROR::no token error!");
        setTimeout(function() {
            location.replace('./login.html');
        }, 0);
    }

    // avalon global stuff when app init
    avalon.illyGlobal = {

        viewani    : global_viewload_animation_name,
        token      : token,
        apiBaseUrl : apiBaseUrl,
        illyDomain : illy_domain,
        imagesBaseSrc: illy_images_base_src,
        resourceBaseUrl: illy_resource_base_url

    };

    // 定义一个顶层的vmodel，用来放置全局共享数据, 挂载在html元素上
    var root = avalon.define({
        $id: "root", // in html or body
        namespace: 'question', // module namespace, for global cachePrefix use
        mainPage: 'question.index', // 项目的主页,供一些错误redirect
        resetConfig: ['detail', 'form'], // 配置需要每次都恢复滚动到页头的视图
        currentState: '', // list question wrong info result...
        currentAction: '', // onBegin onLoad onBeforeUnload onUnload onError...
        currentDataDone: false, // 由$http模块函数唯一改变
        currentIsVisited: false, // boolean flag
        title: ''
    });

    // ==================== custom project data end @include ==================== //

    
    // ==================== app actionController start @include ==================== //

    // 针对本模块做action的监听和处理
    root.$watch('currentAction', function(currentAction) {
        if (currentAction !== void 0) {
            
            switch (currentAction) {

                // -------------------- onError start -------------------- //
                case 'onError':
                    avalon.log("Error!, Redirect to index!", arguments);
                    avalon.router.go(root.mainPage);
                    break;
                // -------------------- onError end -------------------- //
            
                // -------------------- onBegin start -------------------- //
                case 'onBegin':
                    
                    break;
                // -------------------- onBegin end -------------------- //

                // -------------------- onLoad start -------------------- //
                case 'onLoad':

                    // var view = document.querySelector('[avalonctrl='+ root.currentState + ']');
                    // for strong
                    // view && view.classList.add(g_viewload_animation); /* jshint ignore:line */

                    break;
                // -------------------- onLoad end -------------------- //

                // -------------------- onBeforeUnload end -------------------- //
                case 'onBeforeUnload':
                    break;
                // -------------------- onBeforeUnload end -------------------- //

                // -------------------- onUnload start -------------------- //
                case 'onUnload':
                    break;
                // -------------------- onUnload end -------------------- //

            } // end of root.currentAction switch

        } // end of if
    }); // end of root.currentAction watcher
    // ==================== app actionController start @include ==================== //

    
    // ==================== app components area start @include ==================== // 

    /**
     *  components: order is important
     *
     *  getCurrentState(base)
     *  doIsVisitedCheck(base)
     *
     *  loading
     *  resetScrollbar
     *  badNetworkHandle
     *  setTitle
     *
     */

    /** 
     * onBegin
     *   getCurrentState (非可见性组件)
     *   doIsVisitedCheck (非可见性组件)
     *   loadingBeginHandler (开始等待页面渲染)
     *   bindBadNetworkHandler (非可见性组件)
     *
     * onLoad
     *   setTitle (非可见性组件)
     *   scrollBar.setScrollbar (非可见性组件)
     *   loadingEndHandler (针对无异步数据获取的页面)
     *   unbindBadNetworkHandler (非可见性组件)
     *   pushPageState (非可见性组件)
     *
     * onRendered(自定义生命周期)
     *   loadingEndHandler (针对等待异步数据获取的页面)
     *   
     * onBeforeUnload
     *   updatePageState (非可见性组件)
     */

    // getCurrentState component start //
    
    // TODO: 改进来应对复杂多重嵌套后的state, 现在是约定最多三级且和vm的命名相同
    var getCurrentState = function getCurrentState() {
        var state1 = mmState.currentState.stateName.split(".")[1]; // 第二个
        var state2 = mmState.currentState.stateName.split(".")[2]; // 第三个
        if (state2 === void 0) {
            return state1;
        } else {
            return state2;
        }
    };

    root.$watch('currentAction', function(currentAction) {
        if (currentAction === 'onLoad') {
            root.currentState = getCurrentState();
        }
    });

    // getCurrentState component end //
    
    // visitedChecker component start //
    
    // 页面访问统计容器
    // pageId + '-' + scrollTop
    // 最终形成类似结构:['indexPage-120', 'detail/aafsjfjoidsjfi-108', 'list/safdudshfiu-90']
    var CACHE_VISITED_PAGEID_CONTAINER = [];

    // 统一的页面key生成器, 统一有助于全局配置
    var generatePageId = function generatePageId() {
        var pageId = location.href.split('!')[1];
        if (pageId === '/') { // 特殊化处理'/'页面, 所有页面都有'/', 导致错误
            pageId = 'indexPage';
        }
        // console.log(CACHE_VISITED_PAGEID_CONTAINER);
        return pageId;
    };

    var doIsVisitedCheck = function doIsVisitedCheck(callback) {

        var pageId = generatePageId();
        var container = CACHE_VISITED_PAGEID_CONTAINER;
        var isVisited = false;
        for (var i = 0, len = container.length; i < len; i++) { 
            if (container[i].indexOf(pageId) >= 0) {
                isVisited = true;
                break;
            }
        }

        if (callback && typeof callback === 'function') {
            callback();
        }

        return isVisited; 

    };

    root.$watch('currentAction', function(currentAction) {
        if (currentAction === 'onBegin') {
            root.currentIsVisited = doIsVisitedCheck();
        }
    });

    // visitedChecker component end //
     
    // loading component start //

    var loadingBeginHandler = function loadingBeginHandler(loader, callback) {

        if (typeof loader === 'function') { // deal with only one arguments and is callback
            callback = loader;
            loader = void 0;
        }

        loader = global_loader_dom || document.querySelector(global_loader_className);

        var showLoader = function() {
            loader && (loader.style.display = ''); /* jshint ignore:line */
        };

        // loader show logic
        var always_show_loader = global_always_show_loader === true ? true : false;
        if (always_show_loader) {
            showLoader();
        } 
        if (!always_show_loader && !root.currentIsVisited) {
            showLoader();
        }

        if (callback && typeof callback === 'function') {
            callback();
        }

    };

    var loadingEndHandler = function loadingEndHandler(loader, callback) {

        if (typeof loader === 'function') { // deal with only one arguments and is callback
            callback = loader;
            loader = void 0;
        }

        loader = global_loader_dom || document.querySelector(global_loader_className);

        var hideLoader = function() {
            loader && (loader.style.display = 'none'); /* jshint ignore:line */
        };

        if (global_rendered_time === void 0) {
            global_rendered_time = 1000;
            avalon.illyWarning('no global_rendered_time set!');
        }

        setTimeout(function() { 
            hideLoader();
            if (callback && typeof callback === 'function') {
                callback();
            }
        }, global_rendered_time);

    };

    root.$watch('currentAction', function(currentAction) {
        if (currentAction === 'onBegin') {
            loadingBeginHandler();
        }

        // deal with not wait ajax page, like get data from parent vm
        if ( currentAction === 'onLoad' ) {
            if (root.currentDataDone || root.currentIsVisited) {
                loadingEndHandler();
            }
        }
    });

    /** 
     * 201511031617
     * 框架并不能支持异步数据获取情况检测，也就是ajax获取数据
     * 的结果需要自己监听状态，然后为框架添加一个生命周期标记
     * 命名为currentDataDone，对于不需要的页面跳转，比如从父
     * vm获取部分数据来渲染页面也符合逻辑，并在onload就及时
     * loadingEndHandler，整体顺畅实现整个页面生命周期管理。
     *
     * 但是，对于更细致的数据比如图片究竟是否获取完成就只能
     * 加delay来勉强应对大多数情况了,在单页应用这种页面复用
     * 来说，就会出现新页面相同位置保存旧页面的图片数据，有
     * 一定的用户体验不好的地方。
     */

    // ajax data done, invoking loadingEndHandler
    root.$watch('currentDataDone', function(rendered) {
        if (rendered === true) {
            loadingEndHandler();
        }
    });

    // loading component end // 
     
    // resetScrollbar component start //
    
    var resetScrollbarWhenViewLoaded = function resetScrollbarWhenViewLoaded(scrollTop) {
        scrollTop = scrollTop || 0;
        document.body.scrollTop = scrollTop;
        document.documentElement.scrollTop = scrollTop;
    };

    // 检查页面是否需要智能重置滚动位置, 还是直接重置到顶部
    var checkResetScrollConfig = function(configArr) {
        var current = root.currentState;
        return configArr.some(function(item) {
            return item === current;
        });
    };

    // 从页面信息缓存中获取当前页面滚动历史, 用于智能重置滚动位置
    var getCurrentScrollTopRecord = function() {
        var pageId = generatePageId();
        if (CACHE_VISITED_PAGEID_CONTAINER.length > 0) {
            for (var i = CACHE_VISITED_PAGEID_CONTAINER.length - 2; i >= 0; i--) { // 倒序遍历, 且忽略最后一个，因为由于业务逻辑设计，最后一个就是当前，还没滚动数值后缀
                if (CACHE_VISITED_PAGEID_CONTAINER[i].indexOf(pageId) >= 0) {
                    var ret = CACHE_VISITED_PAGEID_CONTAINER[i].split('-')[1];
                    // alert(CACHE_VISITED_PAGEID_CONTAINER); // 奇怪，pc模拟测试就不正确，但是手机端实测是正确的
                    return ret;
                }
            }
        }

        return 0;
    };

    // 获取当前页面滚动高度
    var getCurrentPageScrollTop = function() {
        return document.body.scrollTop;
    };

    // 写入页面信息统计容器
    var pushPageState = function() {
        var pageId = generatePageId();
        if (pageId !== void 0 && CACHE_VISITED_PAGEID_CONTAINER) {
            CACHE_VISITED_PAGEID_CONTAINER.push(pageId);
        }
    };

    // 更新页面信息统计, 在原来基础上增加离开时页面滚动情况信息
    var updatePageState = function() {
        var len = CACHE_VISITED_PAGEID_CONTAINER.length;
        if (len >= 1) {
            if (CACHE_VISITED_PAGEID_CONTAINER[len - 1].indexOf('-') < 0) { // 防止重复更新，针对$http.rejectInterceptor pop情况
                CACHE_VISITED_PAGEID_CONTAINER[len - 1] = CACHE_VISITED_PAGEID_CONTAINER[len - 1] + '-' + getCurrentPageScrollTop();
            }
        }
    };

    root.$watch('currentAction', function(currentAction) {
        if (currentAction === 'onBeforeUnload') {
            updatePageState();
        }

        if (currentAction === 'onLoad') {
            pushPageState(); 
            if (global_always_reset_scrollbar === true) {
                resetScrollbarWhenViewLoaded();
            } else {
                var config = [];
                if (root.resetConfig.length !== 0) {
                    config = root.resetConfig.$model || [];
                }
                var reset = checkResetScrollConfig(config);
                if (!root.currentIsVisited || reset) {
                    resetScrollbarWhenViewLoaded();
                } else {
                    var scrollTop = getCurrentScrollTopRecord();
                    resetScrollbarWhenViewLoaded(scrollTop);
                }
            }
        }
    });

    // resetScrollbar component end // 
     
    // badNetworkHandler component start // 
    
    // deal with bad network condition for wait too long, auto-back when time enough with tip
    var bindBadNetworkHandler = function bindBadNetworkHandler(timeout) {

        // remove old handler first
        badNetworkTimer && (clearTimeout(badNetworkTimer)); /* jshint ignore:line */

        timeout = global_loading_timeout;
        var loader = global_loader_dom || document.querySelector(global_loader_className);

        var badNetworkTimer = setTimeout(function() {
            alert('对不起，您的网络状态暂时不佳，请稍后重试！');
            // 直接返回的处理方式，不过也值得商榷
            history.go(-1);
            // for strong, need ()
            loader && (loader.style.display = 'none'); /* jshint ignore:line */
        }, timeout);

        avalon.badNetworkTimer = badNetworkTimer;

    };

    var unbindBadNetworkHandler = function unbindBadNetworkHandler(timer) {
        timer = timer || avalon.badNetworkTimer;
        timer && clearTimeout(timer); /* jshint ignore:line */
    };

    root.$watch('currentAction', function(currentAction) {
        if (currentAction === 'onBegin') {
            bindBadNetworkHandler();
        }
        if (currentAction === 'onLoad') {
            unbindBadNetworkHandler();
        }
    });

    // badNetworkHandler component end //
    
    // setTitle component start //
    
    var setPageTitle = function setPageTitle(titleMap) {
        titleMap = titleMap || ACTIONBAR_TITLE_MAP;
        var currentState = root.currentState;
        root.title = titleMap[currentState];
    };

    root.$watch('currentAction', function(currentAction) {
        if (currentAction === 'onLoad') {
            setPageTitle();
        }
    });

    // setTitle component end // 

    // ==================== app components area end @include ==================== //


    // ==================== wxsdk-config start @include ==================== //

    // 挂载微信sdk对象到avalon以供全局调用
    avalon.wx = wx;

    var uri = location.href.split("#")[0];
    var url = encodeURIComponent(uri);

    $http.ajax({
        url: apiBaseUrl + 'public/sdk/signature',
        data: {
            url: url
        },
        success: function(jsonobj) {
            var appId = jsonobj.appid;
            var timestamp = jsonobj.timestamp;
            var nonceStr = jsonobj.nonceStr;
            var signature = jsonobj.signature;
            // config the wx-sdk
            wx.config({
                debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
                appId: appId, // 必填，公众号的唯一标识
                timestamp: timestamp, // 必填，生成签名的时间戳
                nonceStr: nonceStr, // 必填，生成签名的随机串
                signature: signature, // 必填，签名，见附录1
                jsApiList: [
                    'checkJsApi',
                    'onMenuShareTimeline',
                    'onMenuShareAppMessage',
                    'onMenuShareQQ',
                    'onMenuShareWeibo',
                    'hideMenuItems',
                    'showMenuItems',
                    'hideAllNonBaseMenuItem',
                    'showAllNonBaseMenuItem',
                    'translateVoice',
                    'startRecord',
                    'stopRecord',
                    'onRecordEnd',
                    'playVoice',
                    'pauseVoice',
                    'stopVoice',
                    'uploadVoice',
                    'downloadVoice',
                    'chooseImage',
                    'previewImage',
                    'uploadImage',
                    'downloadImage',
                    'getNetworkType',
                    'openLocation',
                    'getLocation',
                    'hideOptionMenu',
                    'showOptionMenu',
                    'closeWindow',
                    'scanQRCode',
                    'chooseWXPay',
                    'openProductSpecificView',
                    'addCard',
                    'chooseCard',
                    'openCard'
                ] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2
            });
        },
        error: function(res) {
            avalon.illyError('wx ajax error!', res);
        },
        ajaxFail: function(res) {
            avalon.illyError('wx ajax failed!', res);
        }
    });

    // ready后可调用通用处理
    //wx.ready(function() {
    //    // do all thing here, except user trigger functions(can put in outside)
    //    wx.checkJsApi({
    //        jsApiList: ['startRecord'], // apis to check
    //            success: function(res) {
    //                alert(parse(res));
    //                // key --- value, if usable, true, then false
    //                // e.g. {"checkResult": {"chooseImage": true}, "errMsg": "checkJsApi:ok"}
    //            }
    //    });
    //});

    wx.error(function(res) {
        alert("Woops, error comes..." + res);
    });

    // ====================  wxsdk-config end @include ==================== //
    

    // ==================== router start @include ==================== //

    // for router config
    var _v = '?v=' + resource_version;
    var templateBaseUrl = global_templateBaseUrl + root.namespace + '/';
    var controllerBaseUrl = global_controllerBaseUrl + root.namespace + '/';

    // title Map， 映射各种状态的action-bar title
    var ACTIONBAR_TITLE_MAP = {
        'index': '',
        'form': '问题描述',
        'list': '当前提问',
        'history': '过往提问',
        'detail': '解答详情'
    };

    // 可借助静态编译提前填充avalon.templateCache以便减少http请求，提高加载速度
    
    // 定义一个全局抽象状态，用来渲染通用不会改变的视图，比如header，footer
    avalon.state("question", { // task.js这个控制器接管整个应用控制权
        url: "/",
        abstract: true, // 抽象状态，不会对应到url上, 会立即绘制index这个view
        views: {
            "header": {
                templateUrl: templateBaseUrl + 'header.html', // 指定模板地址
                controllerUrl: controllerBaseUrl + 'header.js' + _v, // 指定控制器地址
            },
            "": {
                templateUrl: templateBaseUrl + 'question.html', // 指定模板地址
                controllerUrl: controllerBaseUrl + 'question.js' + _v, // 指定控制器地址
            },
            "footer@": { // 视图名字的语法请仔细查阅文档
                templateUrl: "assets/templates/footer.html", // 指定模板地址
            }
        }
    })
    .state("question.index", { // 首页(引导拍照提问, 同时引导文字提问链接至detail)
        url: "",
        views: {
            "": {
                templateUrl: templateBaseUrl + 'index.html', // 指定模板地址
                controllerUrl: controllerBaseUrl + 'index.js' + _v, // 指定控制器地址
            }
        }
    })
    .state("question.form", { // 提问补充(图片提问和文字提问)
        url: "form",
        views: {
            "": {
                templateUrl: templateBaseUrl + 'form.html', // 指定模板地址
                controllerUrl: controllerBaseUrl + 'form.js' + _v, // 指定控制器地址
            }
        }
    })
    .state("question.result", { // 提问结果(抽象父状态， 包含提问列表和过往提问历史)
        abstract: true,
        views: {
            "": {
                templateUrl: templateBaseUrl + 'result.html', // 指定模板地址
                controllerUrl: controllerBaseUrl + 'result.js' + _v, // 指定控制器地址
            }
        }
    })
    .state("question.result.list", { // 提问列表(当前未被解答的提问) 
        url: "list",
        views: {
            "": {
                templateUrl: templateBaseUrl + 'list.html', // 指定模板地址
                controllerUrl: controllerBaseUrl + 'list.js' + _v, // 指定控制器地址
            }
        }
    })
    .state("question.result.history", { // 过往提问
        url: "history",
        views: {
            "": {
                templateUrl: templateBaseUrl + 'history.html', // 指定模板地址
                controllerUrl: controllerBaseUrl + 'history.js' + _v, // 指定控制器地址
            }
        }
    })
    .state("question.detail", { // 过往提问
        url: "detail/{questionId}",
        views: {
            "": {
                templateUrl: templateBaseUrl + 'detail.html', // 指定模板地址
                controllerUrl: controllerBaseUrl + 'detail.js' + _v, // 指定控制器地址
            }
        }
    })

    // ==================== router end @include ==================== //

    
    // ==================== state config start @include ==================== //

    /*
    *  @interface avalon.state.config 全局配置
    *  @param {Object} config 配置对象
    *  @param {Function} config.onBeforeUnload 开始切前的回调，this指向router对象，第一个参数是fromState，第二个参数是toState，return false可以用来阻止切换进行
    *  @param {Function} config.onAbort onBeforeUnload return false之后，触发的回调，this指向mmState对象，参数同onBeforeUnload
    *  @param {Function} config.onUnload url切换时候触发，this指向mmState对象，参数同onBeforeUnload
    *  @param {Function} config.onBegin  开始切换的回调，this指向mmState对象，参数同onBeforeUnload，如果配置了onBegin，则忽略begin
    *  @param {Function} config.onLoad 切换完成并成功，this指向mmState对象，参数同onBeforeUnload
    *  @param {Function} config.onViewEnter 视图插入动画函数，有一个默认效果
    *  @param {Node} config.onViewEnter.arguments[0] 新视图节点
    *  @param {Node} config.onViewEnter.arguments[1] 旧的节点
    *  @param {Function} config.onError 出错的回调，this指向对应的state，第一个参数是一个object，object.type表示出错的类型，比如view表示加载出错，object.name则对应出错的view name，object.xhr则是当使用默认模板加载器的时候的httpRequest对象，第二个参数是对应的state
    */

    // 每次view载入都会执行的回调，适合来做一些统一操作
    avalon.state.config({
        onError: function() {
            root.currentAction = 'onError';
        },
        onBeforeUnload: function() { // 太宽泛了，放到具体ctrl里处理
            root.currentAction = 'onBeforeUnload';
        },
        onUnload: function() { // url变化时触发
            root.currentAction = 'onUnload';
        },
        onBegin: function() {
            root.currentAction = 'onBegin';
        },
        onLoad: function() { // 切换完成并成功
            root.currentAction = 'onLoad';
        }
    }); 

    // ====================  state config end @include ==================== //

    
    // exports 
    return {
        init: function() { // init router and bootstrap the app

            // avalon take charge of everything and start to init the app
            avalon.log("init to bootstrap the app!");
            var initTime = Date.now();
            avalon.initTime = initTime;

            avalon.history.start({
                // basepath: "/mmRouter",
                fireAnchor: false
                //,routeElementJudger: function(ele, href) {
                //    avalon.log(arguments);
                //    //return href;
                //}
            });

            //go!!!!!!!!!
            avalon.scan();

        }
    }; // end of exports


});

